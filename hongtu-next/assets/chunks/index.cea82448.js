var i=63710088e-1,l={centimeters:i*100,centimetres:i*100,degrees:360/(2*Math.PI),feet:i*3.28084,inches:i*39.37,kilometers:i/1e3,kilometres:i/1e3,meters:i,metres:i,miles:i/1609.344,millimeters:i*1e3,millimetres:i*1e3,nauticalmiles:i/1852,radians:1,yards:i*1.0936},f={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,nauticalmiles:29155334959812285e-23,millimeters:1e6,millimetres:1e6,yards:1.195990046};function a(r,e,t={}){const n={type:"Feature"};return(t.id===0||t.id)&&(n.id=t.id),t.bbox&&(n.bbox=t.bbox),n.properties=e||{},n.geometry=r,n}function p(r,e,t={}){switch(r){case"Point":return g(e).geometry;case"LineString":return y(e).geometry;case"Polygon":return c(e).geometry;case"MultiPoint":return b(e).geometry;case"MultiLineString":return w(e).geometry;case"MultiPolygon":return d(e).geometry;default:throw new Error(r+" is invalid")}}function g(r,e,t={}){if(!r)throw new Error("coordinates is required");if(!Array.isArray(r))throw new Error("coordinates must be an Array");if(r.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!u(r[0])||!u(r[1]))throw new Error("coordinates must contain numbers");return a({type:"Point",coordinates:r},e,t)}function P(r,e,t={}){return m(r.map(n=>g(n,e)),t)}function c(r,e,t={}){for(const o of r){if(o.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(o[o.length-1].length!==o[0].length)throw new Error("First and last Position are not equivalent.");for(let s=0;s<o[o.length-1].length;s++)if(o[o.length-1][s]!==o[0][s])throw new Error("First and last Position are not equivalent.")}return a({type:"Polygon",coordinates:r},e,t)}function v(r,e,t={}){return m(r.map(n=>c(n,e)),t)}function y(r,e,t={}){if(r.length<2)throw new Error("coordinates must be an array of two or more positions");return a({type:"LineString",coordinates:r},e,t)}function M(r,e,t={}){return m(r.map(n=>y(n,e)),t)}function m(r,e={}){const t={type:"FeatureCollection"};return e.id&&(t.id=e.id),e.bbox&&(t.bbox=e.bbox),t.features=r,t}function w(r,e,t={}){return a({type:"MultiLineString",coordinates:r},e,t)}function b(r,e,t={}){return a({type:"MultiPoint",coordinates:r},e,t)}function d(r,e,t={}){return a({type:"MultiPolygon",coordinates:r},e,t)}function F(r,e,t={}){return a({type:"GeometryCollection",geometries:r},e,t)}function S(r,e=0){if(e&&!(e>=0))throw new Error("precision must be a positive number");const t=Math.pow(10,e||0);return Math.round(r*t)/t}function E(r,e="kilometers"){const t=l[e];if(!t)throw new Error(e+" units is invalid");return r*t}function h(r,e="kilometers"){const t=l[e];if(!t)throw new Error(e+" units is invalid");return r/t}function k(r,e){return A(h(r,e))}function x(r){let e=r%360;return e<0&&(e+=360),e}function L(r){return r=r%360,r>0?r>180?r-360:r:r<-180?r+360:r}function A(r){return r%(2*Math.PI)*180/Math.PI}function T(r){return r%360*Math.PI/180}function q(r,e="kilometers",t="kilometers"){if(!(r>=0))throw new Error("length must be a positive number");return E(h(r,e),t)}function C(r,e="meters",t="kilometers"){if(!(r>=0))throw new Error("area must be a positive number");const n=f[e];if(!n)throw new Error("invalid original units");const o=f[t];if(!o)throw new Error("invalid final units");return r/n*o}function u(r){return!isNaN(r)&&r!==null&&!Array.isArray(r)}function O(r){return r!==null&&typeof r=="object"&&!Array.isArray(r)}function G(r){if(!r)throw new Error("bbox is required");if(!Array.isArray(r))throw new Error("bbox must be an Array");if(r.length!==4&&r.length!==6)throw new Error("bbox must be an Array of 4 or 6 numbers");r.forEach(e=>{if(!u(e))throw new Error("bbox must only contain numbers")})}function j(r){if(!r)throw new Error("id is required");if(["string","number"].indexOf(typeof r)===-1)throw new Error("id must be a number or a string")}const I=Object.freeze(Object.defineProperty({__proto__:null,areaFactors:f,azimuthToBearing:L,bearingToAzimuth:x,convertArea:C,convertLength:q,degreesToRadians:T,earthRadius:i,factors:l,feature:a,featureCollection:m,geometry:p,geometryCollection:F,isNumber:u,isObject:O,lengthToDegrees:k,lengthToRadians:h,lineString:y,lineStrings:M,multiLineString:w,multiPoint:b,multiPolygon:d,point:g,points:P,polygon:c,polygons:v,radiansToDegrees:A,radiansToLength:E,round:S,validateBBox:G,validateId:j},Symbol.toStringTag,{value:"Module"}));function N(r){if(!r)throw new Error("coord is required");if(!Array.isArray(r)){if(r.type==="Feature"&&r.geometry!==null&&r.geometry.type==="Point")return[...r.geometry.coordinates];if(r.type==="Point")return[...r.coordinates]}if(Array.isArray(r)&&r.length>=2&&!Array.isArray(r[0])&&!Array.isArray(r[1]))return[...r];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function _(r){if(Array.isArray(r))return r;if(r.type==="Feature"){if(r.geometry!==null)return r.geometry.coordinates}else if(r.coordinates)return r.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function z(r){return r.type==="Feature"?r.geometry:r}export{v as A,E as B,S as C,G as D,j as E,z as F,_ as G,I as H,c as a,f as b,L as c,T as d,x as e,C as f,N as g,q as h,u as i,i as j,l as k,a as l,m,p as n,F as o,g as p,O as q,A as r,k as s,h as t,y as u,M as v,w,b as x,d as y,P as z};
